#include <stdio.h>
#include <Windows.h>

#define NEW_STREAM L":NEWDATA"

BOOL SelfDelete() {
    WCHAR szPath[MAX_PATH * 2] = { 0 };
    WCHAR szRenamedPath[MAX_PATH * 2] = { 0 };
    FILE_DISPOSITION_INFO Delete = { 0 };
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PFILE_RENAME_INFO pRename = NULL;
    const wchar_t* NewStream = (const wchar_t*)NEW_STREAM;
    SIZE_T StreamLength = wcslen(NewStream) * sizeof(wchar_t);
    SIZE_T sRename = sizeof(FILE_RENAME_INFO) + StreamLength;

    // Get current file path
    if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
        printf("GetModuleFileNameW Failed With Error: %d\n", GetLastError());
        return FALSE;
    }

    // Allocate buffer for FILE_RENAME_INFO structure
    pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
    if (!pRename) {
        printf("HeapAlloc failed with error %d\n", GetLastError());
        return FALSE;
    }

    // Mark file for deletion
    Delete.DeleteFile = TRUE;

    // Set up rename information
    pRename->ReplaceIfExists = TRUE;  // Important: allow replacing if stream exists
    pRename->RootDirectory = NULL;
    pRename->FileNameLength = StreamLength;
    memcpy(pRename->FileName, NewStream, StreamLength);

    // Open handle for renaming
    hFile = CreateFileW(szPath,
        DELETE | SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("CreateFileW (for rename) Failed With Error %d\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, pRename);
        return FALSE;
    }

    wprintf(L"Renaming :$DATA to %s ...", NEW_STREAM);

    // Rename the default data stream
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
        DWORD error = GetLastError();
        printf("SetFileInformationByHandle (rename) Failed With Error %d\n", error);
        CloseHandle(hFile);
        HeapFree(GetProcessHeap(), 0, pRename);

        // Try direct deletion if rename fails
        hFile = CreateFileW(szPath, DELETE, FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            if (SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
                CloseHandle(hFile);
                HeapFree(GetProcessHeap(), 0, pRename);
                return TRUE;
            }
            CloseHandle(hFile);
        }
        return FALSE;
    }

    wprintf(L"Done\n");
    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), 0, pRename);

    // Construct the path with the new stream name
    wcscpy_s(szRenamedPath, MAX_PATH * 2, szPath);
    wcscat_s(szRenamedPath, MAX_PATH * 2, NEW_STREAM);

    // Open handle to the renamed stream for deletion
    hFile = CreateFileW(szRenamedPath,
        DELETE | SYNCHRONIZE,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        // Try opening without the stream name (the file itself)
        hFile = CreateFileW(szPath,
            DELETE | SYNCHRONIZE,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
            NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            // File might already be deleted or inaccessible
            return TRUE;
        }
    }

    wprintf(L"Deleting...");

    // Mark for deletion
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
        printf("SetFileInformationByHandle (delete) Failed With Error %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    wprintf(L"Done\n");
    CloseHandle(hFile);

    return TRUE;
}

int main() {
    if (SelfDelete()) {
        printf("Self-deletion completed successfully.\n");
    }
    else {
        printf("Self-deletion failed.\n");
    }

    return 0;
}
