#include <Windows.h>
#include <tlhelp32.h>
#include <stdio.h>

// -----------------------------------------------------------
// SAFE EDUCATIONAL PROJECT
// -----------------------------------------------------------
// This PoC demonstrates:
// 1. Enumerating processes
// 2. Opening a remote process handle
// 3. Allocating memory inside the remote process
// 4. Writing a dummy buffer (NOT shellcode)
// 
//
// NOTE: There is NO shellcode, NO remote thread, NO execution.
// -----------------------------------------------------------

// Find process by name, return handle + PID (safe)
BOOL GetHandleProc(LPCWSTR ProcName, HANDLE* hProcess, DWORD* dwPid) {
    if (!ProcName || !hProcess || !dwPid) return FALSE;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        wprintf(L"CreateToolhelp32Snapshot failed: %lu\n", GetLastError());
        return FALSE;
    }

    PROCESSENTRY32W pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32W);

    if (!Process32FirstW(hSnapshot, &pe32)) {
        wprintf(L"Process32FirstW failed: %lu\n", GetLastError());
        CloseHandle(hSnapshot);
        return FALSE;
    }

    BOOL found = FALSE;
    do {
        if (_wcsicmp(pe32.szExeFile, ProcName) == 0) {
            *dwPid = pe32.th32ProcessID;
            *hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, FALSE, *dwPid);
            if (*hProcess == NULL) {
                wprintf(L"OpenProcess failed for PID %lu: %lu\n", *dwPid, GetLastError());
                CloseHandle(hSnapshot);
                return FALSE;
            }
            found = TRUE;
            break;
        }
    } while (Process32NextW(hSnapshot, &pe32));

    CloseHandle(hSnapshot);

    if (!found) {
        wprintf(L"Process not found: %s\n", ProcName);
        return FALSE;
    }

    return TRUE;
}

// Safe "Injection": Only writes a harmless buffer (not executed)
BOOL SafeMemoryWrite(HANDLE hProcess) {
    if (!hProcess) return FALSE;

    // Dummy buffer â€” NOT shellcode
    BYTE buffer[] = {
        0x90, 0x90, 0x90, 0x90, // NOPs as placeholder
        0x00                    // NULL terminator
    };
    SIZE_T bufSize = sizeof(buffer);

    // Allocate RW memory (NOT executable)
    LPVOID remote = VirtualAllocEx(
        hProcess, NULL, bufSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if (!remote) {
        printf("VirtualAllocEx failed: %lu\n", GetLastError());
        return FALSE;
    }

    SIZE_T written = 0;
    if (!WriteProcessMemory(hProcess, remote, buffer, bufSize, &written)) {
        printf("WriteProcessMemory failed: %lu\n", GetLastError());
        VirtualFreeEx(hProcess, remote, 0, MEM_RELEASE);
        return FALSE;
    }

    wprintf(L"[OK] Successfully wrote %llu bytes to remote process memory.\n", written);
    wprintf(L"[INFO] Memory is NOT executable. No code is run.\n");

    return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {
    if (argc < 2) {
        wprintf(L"Usage: %s <process_name>\n", argv[0]);
        return -1;
    }

    HANDLE hProcess = NULL;
    DWORD pid = 0;

    if (!GetHandleProc(argv[1], &hProcess, &pid)) {
        wprintf(L"Failed to obtain process handle.\n");
        return -1;
    }

    wprintf(L"[+] Found process %s (PID: %lu)\n", argv[1], pid);

    if (!SafeMemoryWrite(hProcess)) {
        wprintf(L"Memory write failed.\n");
        CloseHandle(hProcess);
        return -1;
    }

    wprintf(L"[+] Safe memory operation completed.\n");
    CloseHandle(hProcess);
    return 0;
}
