# Code Breakdown 

## What This Code Does
This program demonstrates **APC (Asynchronous Procedure Call) execution** by queuing a function to a thread that is in an **alertable state**.  
The payload is **benign** and only displays a message box, proving APC execution without using shellcode or remote process injection.

---

## Main Components

---

### 1. APC Payload
```c
VOID CALLBACK ApcPayload(ULONG_PTR dwParam)
```
**Purpose:**
Defines the function that will be executed via APC.

**How:**
Uses a valid APC callback signature and calls MessageBoxW.

**Result:**
Provides visible proof that the APC was executed successfully.

---

### 2. Safe Memory Operations
```c
DWORD WINAPI AlertableThread(LPVOID lpParam)
```

**Purpose:**
Creates a thread capable of executing APCs.

**Safety:**
Calls SleepEx(INFINITE, TRUE) to enter an alertable wait state.

**Why important:**
APCs are only delivered when a thread is alertable.

---

### 3. Thread Creation
```c
CreateThread(...)
```

**Purpose:**
Creates a local thread under the program’s control.

**Safety:**
No remote process interaction, no privilege escalation.

**Why important:**
APCs are only delivered when a thread is alertable.

---

### 4. APC Queuing
```c
QueueUserAPC((PAPCFUNC)ApcPayload, hThread, NULL)
```

**Purpose:**
Queues the APC payload for execution.

**How:**
Windows stores the APC until the thread enters an alertable state.

**Result:**
The payload executes inside the target thread.

---

### 5. Program Flow
```c
int main(void)
```

**Create Thread:**
Starts the alertable thread.

**Queue APC:**
Schedules the payload for execution.

**Wait:**
Keeps the program alive until execution completes.

**Cleanup:**
Closes the thread handle properly.

---

## Key Safety Features

✅ **No shellcode execution** : only legitimate API calls
✅ **No RWX memory** : no executable allocations
✅ **No remote process injection** : local thread only
✅ **Clear execution flow** : easy to analyze and explain

---

